{% extends 'layout.twig' %}

{% block body %}
    <div class="flex">
        <div id="svg"></div>
        <div id="infos">
        <div id="infos-centered">
            <h2>Hello</h2>
            <p>CHEVRE</p>
        </div>
        </div>
    </div>
{% endblock %}

{% block javascript %}
<script src="/javascripts/d3.v3.min.js"></script>
<script>

var margin = {top: 350, right: 480, bottom: 350, left: 480},
    radius = Math.min(margin.top, margin.right, margin.bottom, margin.left) - 10;

var hue = d3.scale.category10();

var luminance = d3.scale.sqrt()
    .domain([0, 1e6])
    .clamp(true)
    .range([90, 20]);

var svg = d3.select("#svg").append("svg")
    .attr("width", margin.left + margin.right)
    .attr("height", margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var partition = d3.layout.partition()
    .sort(function(a, b) { return d3.ascending(a.name, b.name); })
    .size([2 * Math.PI, radius]);

var arc = d3.svg.arc()
    .startAngle(function(d) { return d.x; })
    .endAngle(function(d) { return d.x + d.dx ; })
    .padAngle(.01)
    .padRadius(radius / 3)
    .innerRadius(function(d) { return radius / 3 * d.depth; })
    .outerRadius(function(d) { return radius / 3 * (d.depth + 1) - 1; });

var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

d3.json("/spells", function(error, root) {
    if (error) throw error;

    // Compute the initial layout on the entire tree to sum sizes.
    // Also compute the full name and fill color for each node,
    // and stash the children so they can be restored as we descend.
    partition
        .value(function(d) { return 1; })
        .nodes(root)
        .forEach(function(d) {
            d._children = d.children;
            d.sum = d.value;
            d.key = key(d);
            d.fill = fill(d);
        });

    // Now redefine the value function to use the previously-computed sum.
    partition
        .children(function(d, depth) { return depth < 2 ? d._children : null; })
        .value(function(d) { return d.sum; });

    var center = svg.append("circle")
        .attr("r", radius / 3)
        .on("click", function(d) {
            zoomOut(d);
            deleteLatestInfos();
        });

    center.append("svg:title")
        .text("zoom out");

    var g = svg.selectAll("path")
        .data(partition.nodes(root).slice(1))
        .enter();
    var path = g.append("path")
        .attr("d", arc)
        .attr("id", function (d, i) {return i;})
        .style("fill", function(d) { return d.fill; })
        .text(function(d) {
            return d.name;
        })
        .each(function(d) { 
            this._current = updateArc(d); })
        .on("click", function(d) {
            zoomIn(d);
            updateInfos(d);
        })
        .on("mouseover", function(d) {
            tooltipOver(d);
        })
        .on("mouseout", function(d) {
            tooltipOut(d);
        });
//    g.append("text")
//        .attr("class", "nodetext")
//        .append("textPath")
//        .attr("href", function (d,i) { return "#" + i; })
//        .text(function (d) {
//            return d.name;
//        });


    function zoomIn(p) {
        if (p.depth > 1) p = p.parent;
        if (!p.children) return;
        zoom(p, p);
    }

    function zoomOut(p) {
        if (!p.parent) return;
        zoom(p.parent, p);
    }

    // Zoom to the specified new root.
    function zoom(root, p) {
        if (document.documentElement.__transition__) return;

        // Rescale outside angles to match the new layout.
        var enterArc,
            exitArc,
            outsideAngle = d3.scale.linear().domain([0, 2 * Math.PI]);

        function insideArc(d) {
            return p.key > d.key
                ? {depth: d.depth - 1, x: 0, dx: 0} : p.key < d.key
                ? {depth: d.depth - 1, x: 2 * Math.PI, dx: 0}
                : {depth: 0, x: 0, dx: 2 * Math.PI};
        }

        function outsideArc(d) {
            return {depth: d.depth + 1, x: outsideAngle(d.x), dx: outsideAngle(d.x + d.dx) - outsideAngle(d.x)};
        }

        center.datum(root);

        // When zooming in, arcs enter from the outside and exit to the inside.
        // Entering outside arcs start from the old layout.
        if (root === p) enterArc = outsideArc, exitArc = insideArc, outsideAngle.range([p.x, p.x + p.dx]);

        path = path.data(partition.nodes(root).slice(1), function(d) { return d.key; });

        // When zooming out, arcs enter from the inside and exit to the outside.
        // Exiting outside arcs transition to the new layout.
        if (root !== p) enterArc = insideArc, exitArc = outsideArc, outsideAngle.range([p.x, p.x + p.dx]);

        d3.transition().duration(d3.event.altKey ? 7500 : 750).each(function() {
            path.exit().transition()
            .style("fill-opacity", function(d) { return d.depth === 1 + (root === p) ? 1 : 0; })
            .attrTween("d", function(d) { return arcTween.call(this, exitArc(d)); })
            .remove();

        path.enter().append("path")
            .style("fill-opacity", function(d) { return d.depth === 2 - (root === p) ? 1 : 0; })
            .style("fill", function(d) { return d.fill; })
            .on("click", function(d) {
                zoomIn(d);
                updateInfos(d);
            })
            .each(function(d) { this._current = enterArc(d); })
            .on("mouseover", function(d) {
                tooltipOver(d);
            })
            .on("mouseout", function(d) {
                tooltipOut(d);
            });

            path.transition()
                .style("fill-opacity", 1)
                .attrTween("d", function(d) { return arcTween.call(this, updateArc(d)); });
        });
    }
});

function key(d) {
    var k = [], p = d;
    while (p.depth) k.push(p.name), p = p.parent;
    return k.reverse().join(".");
}

function fill(d) {
    var p = d;
    while (p.depth > 1) p = p.parent;
    var c = d3.lab(hue(p.name));
    c.l = luminance(d.sum);
    return c;
}

function arcTween(b) {
    var i = d3.interpolate(this._current, b);
    this._current = i(0);
    return function(t) {
        return arc(i(t));
    };
}

function updateArc(d) {
    return {depth: d.depth, x: d.x, dx: d.dx};
}

d3.select(self.frameElement).style("height", margin.top + margin.bottom + "px");

function tooltipOver(d) {
    var details = "<h2>" + d.name + "</h2>";
    if (d.description) {
        details += "<p>" + d.description + "</p>";
}
    tooltip.transition()
        .duration(500)
        .style("opacity", .8);
    tooltip.html(details)
        .style("left", (d3.event.pageX + -100) + "px")
        .style("top", (d3.event.pageY + 30) + "px");

}
function tooltipOut(d) {
    d3.selectAll(".details").remove();
    tooltip.transition()
        .duration(300)
        .style("opacity", 0);
}

function updateInfos(d) {
    let node = document.getElementById("infos-centered");
    let html = '<div';
    if (!d.children) {
        if (node.lastChild.id === 'last') {
            node.removeChild(node.lastChild);
        }
        html += ' id="last"'
    }

    html +="><h2>" + d.name + "</h2>";
    if (d.description) {
        html += "<p>" + d.description + "</p>";
    }
    node.innerHTML += html;
}

function deleteLatestInfos() {
    let node = document.getElementById("infos-centered");
    node.removeChild(node.lastChild) ;
}
</script>
{% endblock %}
